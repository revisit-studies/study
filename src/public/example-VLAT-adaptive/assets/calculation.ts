export const pythonScript : string = 'from collections import OrderedDict\n'
    + 'import pandas as pd\n'
    + 'import numpy as np\n'
    + 'from scipy.stats import norm\n'
    + 'import operator\n'
    + '\n'
    + '\n'
    + 'def irt_likelihood_correct(a, b, theta):\n'
    + '    return 1/(1+np.exp(-a*(theta+b)))\n'
    + '\n'
    + '\n'
    + 'def irt_likelihood_wrong(a, b, theta):\n'
    + '    return 1 - 1/(1+np.exp(-a*(theta+b)))\n'
    + '\n'
    + '\n'
    + 'def item_info_func(a, b, theta):\n'
    + '    return a**2 * irt_likelihood_correct(a, b, theta) * irt_likelihood_wrong(a, b, theta)\n'
    + '\n'
    + '\n'
    + 'def df_to_dict(df):\n'
    + '    new_dict = dict()\n'
    + '    df_list = df.values.tolist()\n'
    + '    unused_chart_task_set = set()\n'
    + '    for i in df_list:\n'
    + '        new_dict[i[0]] = (i[1], i[2], i[3], i[4])\n'
    + '        unused_chart_task_set.add(i[3])\n'
    + '        unused_chart_task_set.add(i[4])\n'
    + '    return new_dict, unused_chart_task_set\n'
    + '\n'
    + '\n'
    + '\n'
    + 'def adaptive_vlat(response_history_dict):\n'
    + '    """Run adaptive algorithm on item response history to select the next item\n'
    + '\n'
    + '    Keyword arguments:\n'
    + '        response_history_dict (OrderedDict) -- an ordered dictonary with item id as keys and item correctness as values\n'
    + '\n'
    + '    Returns:\n'
    + '        next_item (str) -- the item ID of the next item\n'
    + '    """\n'
    + '\n'
    + "    theta_test_tryout = pd.read_csv('data/df_VLAT_ability.csv')\n"
    + "    item_parameters = pd.read_csv('data/df_VLAT_param_medians.csv')\n"
    + '\n'
    + '    item_parameters, unused_chart_task_set = df_to_dict(item_parameters)\n'
    + '    used_chart_task_combo = set()\n'
    + '\n'
    + '    # Get the ability of the participants from test tryout data\n'
    + '    ability_test_tryout = theta_test_tryout.iloc[:, 0:1].values\n'
    + '    # Get the mean of ability from test tryout data\n'
    + '    initial_prior_mean = np.mean(ability_test_tryout)\n'
    + '    # Get the standard deviation of ability from test tryout data\n'
    + '    initial_prior_std = np.std(ability_test_tryout)\n'
    + '\n'
    + '    # Build a grid for grid approximation\n'
    + '    grid_data = np.linspace(-5, 5, 200)\n'
    + '    # Build the initial prior distribution\n'
    + '    prior = norm.pdf(grid_data, initial_prior_mean, initial_prior_std)\n'
    + '\n'
    + '    if len(response_history_dict) == 0:  # If we are picking the first item\n'
    + '        # Then set current ability to the mean of the prior distribution\n'
    + '        current_ability = initial_prior_mean\n'
    + '\n'
    + '    else:\n'
    + '        # Iterate over the items answered so far\n'
    + '        for key, value in response_history_dict.items():\n'
    + '            item_easiness = item_parameters[key][0]\n'
    + '            item_discrimination = item_parameters[key][1]\n'
    + '            item_correctness = value\n'
    + '\n'
    + '            # Remove chart types and tasks of answered items from unused_chart_task_set\n'
    + '            if item_parameters[key][2] in unused_chart_task_set:\n'
    + '                unused_chart_task_set.remove(item_parameters[key][2])\n'
    + '            if item_parameters[key][3] in unused_chart_task_set:\n'
    + '                unused_chart_task_set.remove(item_parameters[key][3])\n'
    + '\n'
    + '            # Add chart type and task combo of answered item to used_chart_task_combo\n'
    + '            used_chart_task_combo.add(\n'
    + '                (item_parameters[key][2], item_parameters[key][3]))\n'
    + '\n'
    + '            if item_correctness == 0:  # If answered incorrectly, invoke the corresponding likelihood function\n'
    + '                likelihood = irt_likelihood_wrong(\n'
    + '                    a=item_discrimination, b=item_easiness, theta=grid_data)\n'
    + '\n'
    + '            else:  # If answered correctly, invoke the corresponding likelihood function\n'
    + '                likelihood = irt_likelihood_correct(\n'
    + '                    a=item_discrimination, b=item_easiness, theta=grid_data)\n'
    + '\n'
    + '            unnormalized_posterior = likelihood * prior\n'
    + '            posterior = unnormalized_posterior / unnormalized_posterior.sum()\n'
    + '            # Update the prior for the next iteration to be the posterior of the current iteration\n'
    + '            prior = posterior\n'
    + '        # Compute the current estimated ability by taking the weighted mean of the posterior\n'
    + '        current_ability = sum(posterior * grid_data)\n'
    + '    # Create dictionary to store remaining items and their item information\n'
    + '    item_info_dict = dict()\n'
    + '    num_left = 27 - len(response_history_dict)\n'
    + '\n'
    + '    if len(unused_chart_task_set) == 0:\n'
    + '        for key, value in item_parameters.items():\n'
    + '            # If item not used yet, compute its item infomation given the current ability\n'
    + '            if key not in response_history_dict:\n'
    + '                item_info = item_info_func(value[1], value[0], current_ability)\n'
    + '                item_info_dict[key] = item_info\n'
    + '        next_item = max(item_info_dict.items(), key=operator.itemgetter(1))[\n'
    + '            0]  # Get the next item that has the maximum item information\n'
    + '\n'
    + '    elif num_left > len(unused_chart_task_set):\n'
    + '        for key, value in item_parameters.items():\n'
    + '            # If item not used yet, compute its item infomation given the current ability\n'
    + '            if (value[2], value[3]) not in used_chart_task_combo:\n'
    + '                item_info = item_info_func(value[1], value[0], current_ability)\n'
    + '                item_info_dict[key] = item_info\n'
    + '        next_item = max(item_info_dict.items(), key=operator.itemgetter(1))[\n'
    + '            0]  # Get the next item that has the maximum item information\n'
    + '    else:\n'
    + '        for key, value in item_parameters.items():\n'
    + '            # If item not used yet, compute its item infomation given the current ability\n'
    + '            if (value[2] in unused_chart_task_set) or (value[3] in unused_chart_task_set):\n'
    + '                item_info = item_info_func(value[1], value[0], current_ability)\n'
    + '                item_info_dict[key] = item_info\n'
    + '        next_item = max(item_info_dict.items(), key=operator.itemgetter(1))[\n'
    + '            0]  # Get the next item that has the maximum item information\n'
    + '\n'
    + '    return next_item,current_ability  # Return item ID for next item\n'
    + '\n'
    + '\n'
    + '\n'
    + 'def getVLATnextqid(qid, correct):\n'
    + '    response_history_dict = OrderedDict()\n'
    + '    for i in range(len(qid)):\n'
    + '        response_history_dict[int(qid[i])] = int(correct[i])\n'
    + '\n'
    + '    item_id, score = adaptive_vlat(\n'
    + '        response_history_dict=response_history_dict\n'
    + '    )\n'
    + '\n'
    + '    print(item_id)\n'
    + '    print(score)\n'
    + '    return item_id, score\n'
    + '\n'
    + '\n';
