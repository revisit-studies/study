<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Study Review</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;margin:24px;line-height:1.35}
    h1{margin:0 0 12px}
    .muted{color:#555}
    .card{border:1px solid #ddd;border-radius:12px;padding:16px;margin:12px 0}
    table{width:100%;border-collapse:collapse;margin-top:10px}
    th,td{border-bottom:1px solid #eee;padding:10px 8px;vertical-align:top;text-align:left}
    th{background:#fafafa;font-weight:600}
    .pill{display:inline-block;padding:2px 10px;border-radius:999px;font-size:12px;border:1px solid #ddd}
    .ok{background:#f0fff4;border-color:#b7ebc6}
    .bad{background:#fff5f5;border-color:#f1b7b7}
    .row-ok td{background:rgba(0,255,0,0.04)}
    .row-bad td{background:rgba(255,0,0,0.04)}
    .small{font-size:13px}
    .controls{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
    button{padding:10px 12px;border-radius:10px;border:1px solid #ccc;background:#fff;cursor:pointer}
    button:hover{background:#f7f7f7}
    textarea{width:100%;min-height:140px;border-radius:10px;border:1px solid #ccc;padding:10px;font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}
    code{background:#f6f6f6;padding:2px 6px;border-radius:6px}
  </style>
</head>
<body>
  <h1>Study Review</h1>
  <p class="muted">This page summarizes which answers you got right and wrong based on the study’s answer key.</p>

  <div class="card" id="summaryCard">
    <div><strong>Score:</strong> <span id="scoreText">—</span></div>
    <div class="small muted" id="scoreDetail">—</div>
  </div>

  <div class="card">
    <strong>Per-question results</strong>
    <div class="small muted">If something looks blank, it usually means your browser didn’t record an answer for that item.</div>
    <table id="resultsTable" aria-label="Results table">
      <thead>
        <tr>
          <th style="width:22%">Component</th>
          <th style="width:30%">Question</th>
          <th style="width:16%">Your answer</th>
          <th style="width:18%">Correct</th>
          <th style="width:14%">Status</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

<script>
(async function() {
  const STORE_KEY = "rrnl_answer_store_v1";

  const scoreText = document.getElementById("scoreText");
  const scoreDetail = document.getElementById("scoreDetail");
  const tbody = document.querySelector("#resultsTable tbody");
  const exportBox = document.getElementById("exportBox");

  const log = (...a) => console.log("[rrnl-results]", ...a);

  function norm(s){ return (s ?? "").toString().trim(); }

  function loadStore() {
    try {
      const raw = localStorage.getItem(STORE_KEY);
      if (!raw) return { version: 1, answers: {} };
      const parsed = JSON.parse(raw);
      if (!parsed.answers || typeof parsed.answers !== "object") parsed.answers = {};
      return parsed;
    } catch {
      return { version: 1, answers: {} };
    }
  }

  async function fetchConfig() {
    const res = await fetch("../config.json", { cache: "no-store" });
    if (!res.ok) throw new Error("Could not load config.json");
    return await res.json();
  }

  function isNumeric(n) {
    return typeof n === "number" && Number.isFinite(n);
  }

  function parseNumberMaybe(v) {
    if (v == null) return null;
    const s = norm(v).replace(/[%\s,]/g, "");
    if (s === "") return null;
    const n = Number(s);
    return Number.isFinite(n) ? n : null;
  }

  function flattenSequence(node) {
    // node can be:
    // - string component key
    // - { order, components: [...] } (nested)
    // - array
    const out = [];
    if (!node) return out;

    if (typeof node === "string") return [node];

    if (Array.isArray(node)) {
      for (const item of node) out.push(...flattenSequence(item));
      return out;
    }

    if (typeof node === "object" && Array.isArray(node.components)) {
      for (const item of node.components) out.push(...flattenSequence(item));
      return out;
    }

    return out;
  }

  function buildCorrectAnswerMap(componentDef) {
    // correctAnswer: [{ id, answer, acceptableLow, acceptableHigh }]
    const map = new Map();
    const arr = componentDef?.correctAnswer;
    if (!Array.isArray(arr)) return map;
    for (const ca of arr) {
      if (ca?.id) map.set(ca.id, ca);
    }
    return map;
  }

  function formatCorrect(ca) {
    if (!ca) return "—";
    const low = ca.acceptableLow;
    const high = ca.acceptableHigh;
    if (isNumeric(low) && isNumeric(high)) {
      if (low === high) return `${low}`;
      return `${low} – ${high}`;
    }
    if (ca.answer != null) return `${ca.answer}`;
    return "—";
  }

  function grade(userValue, ca) {
    if (!ca) return { ok: null, why: "No answer key for this item." };

    const low = ca.acceptableLow;
    const high = ca.acceptableHigh;

    // Range check if present
    if (isNumeric(low) && isNumeric(high)) {
      const userNum = parseNumberMaybe(userValue);
      if (userNum == null) return { ok: false, why: "No numeric answer recorded." };
      const ok = userNum >= low && userNum <= high;
      return { ok, why: ok ? "Within acceptable range." : "Outside acceptable range." };
    }

    // Exact match otherwise
    const expected = ca.answer;
    if (expected == null) return { ok: null, why: "No answer/range in key." };
    const ok = norm(userValue).toLowerCase() === norm(expected).toLowerCase();
    return { ok, why: ok ? "Exact match." : "Does not match." };
  }

  const store = loadStore();
  exportBox.value = JSON.stringify(store, null, 2);

  let config;
  try {
    config = await fetchConfig();
    log("Loaded config keys:", Object.keys(config || {}));
  } catch (e) {
    scoreText.textContent = "—";
    scoreDetail.textContent = "Could not load answer key (config.json).";
    console.error(e);
    return;
  }

  const componentsObj = config?.components;
  const seqRoot = config?.sequence;
  const orderedComponents = flattenSequence(seqRoot?.components);

  if (!componentsObj || typeof componentsObj !== "object") {
    scoreText.textContent = "—";
    scoreDetail.textContent = "config.components is missing.";
    return;
  }

  if (!orderedComponents.length) {
    scoreText.textContent = "—";
    scoreDetail.textContent = "No components found in config.sequence.components.";
    return;
  }

  // Build rows for ONLY components that have a correctAnswer array
  let totalGradable = 0;
  let totalCorrect = 0;
  let rows = 0;

  for (const compName of orderedComponents) {
    const compDef = componentsObj[compName];
    if (!compDef) continue;

    const responseArr = compDef.response;
    const caMap = buildCorrectAnswerMap(compDef);

    // Skip components without answer key (intro, break, participant stats, etc.)
    if (!caMap.size) continue;
    if (!Array.isArray(responseArr) || responseArr.length === 0) continue;

    for (const r of responseArr) {
      const id = r?.id;
      const prompt = r?.prompt ?? "(question)";
      if (!id) continue;

      const ca = caMap.get(id) || null;

      // If there's no key entry for this response, treat as ungraded
      if (!ca) continue;

      totalGradable++;

      const userAnswer = store?.answers?.[compName]?.[id] ?? null;
      const result = grade(userAnswer, ca);
      if (result.ok === true) totalCorrect++;

      const tr = document.createElement("tr");
      tr.className = result.ok ? "row-ok" : "row-bad";

      const statusPill = `<span class="pill ${result.ok ? "ok" : "bad"}">${result.ok ? "Correct" : "Incorrect"}</span>`;

      tr.innerHTML = `
        <td><strong>${compName}</strong><div class="small muted">${id}</div></td>
        <td>${prompt}</td>
        <td>${userAnswer == null ? "<span class='muted'>—</span>" : String(userAnswer)}</td>
        <td>${formatCorrect(ca)}</td>
        <td>${statusPill}<div class="small muted">${result.why}</div></td>
      `;

      tbody.appendChild(tr);
      rows++;
    }
  }

  if (rows === 0) {
    scoreText.textContent = "—";
    scoreDetail.textContent = "No gradable questions found in config.json.";
    return;
  }

  const pct = totalGradable ? Math.round((totalCorrect / totalGradable) * 100) : 0;
  scoreText.textContent = `${totalCorrect} / ${totalGradable} (${pct}%)`;
  scoreDetail.textContent =
    "Grading uses acceptableLow/acceptableHigh for numeric questions and exact match for dropdowns.";

  // Buttons
  document.getElementById("copyBtn").addEventListener("click", async () => {
    try {
      await navigator.clipboard.writeText(exportBox.value);
      alert("Copied!");
    } catch {
      exportBox.select();
      document.execCommand("copy");
      alert("Copied (fallback)!");
    }
  });

  document.getElementById("clearBtn").addEventListener("click", () => {
    if (!confirm("Clear stored answers for the next participant?")) return;
    localStorage.removeItem(STORE_KEY);
    exportBox.value = JSON.stringify({ version: 1, answers: {} }, null, 2);
    alert("Cleared. Refresh if you want the table to reset.");
  });
})();
</script>
</body>
</html>
